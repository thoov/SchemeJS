[* 

var parse = require('./src/parse.js');
var evaluation = require('./src/eval.js');
var constants = require('./src/constants.js');
evaluation.initialize();

*]

/~ Tokens Definitions for Scheme Syntax ~/

/~ Tokens to be ignored (e.g. whitespace, comments) ~/
! ' |\t|\r\n|\n|;[^\n]*\n' 
;

/~ Token pattern matching rules ~/
    '[ ]?\)'                                      RPAREN
    '[ ]?\([ ]?'                                  LPAREN
    '\.'                                          DOT
    '[0-9]+[ ]?|[0-9]+\.[0-9]*|[0-9]*\.[0-9]+'    NUMBER   [* %match = parseFloat( %match ); *]
    '[^\(\)0-9\.\'\`\,\@" ][^\) ]*'               SYMBOL   [* /*symbols cannot begin with digits, parens, quotes, dots, etc.*/ *]
    '\"[^"]*\"'                                   STRING   [* %match = %match.substr( 1, %match.length - 2 ); *]
  ;

##


readonce:   sexpr                                    [* parse.tokenized = %1; *]
            ;

sexpr:      atom                                      
            | list                                   [* %% = %1; *]
            ;

list:       LPAREN RPAREN	                         [* %% = parse.createNull(); *]
            | LPAREN atom members RPAREN             [* %% = parse.createCons(%2, %3); /* a list must first start with a symbol */ *]
            | LPAREN atom RPAREN                     [* %% = parse.createCons(%2); *]
            | LPAREN list RPAREN                     [* %% = parse.createCons(parse.createCons(%2)); *]
            | LPAREN list members RPAREN             [* %% = parse.createCons(parse.createCons(%2), %3); *]
            ;

members:    sexpr members                            [* %% = parse.createCons(%1, %2); *]
            | DOT sexpr                              [* %% = %2; *]
            | sexpr                                  [* %% = parse.createCons(%1); *]
            ;

atom:       NUMBER                                   [* %% = parse.createAtom('NUMBER', %1); *]
            | SYMBOL                                 [* %% = parse.createAtom('SYMBOL', %1); *]
            | STRING                                 [* %% = parse.createAtom('STRING', %1); *]
            ;



[*
var error_offsets = new Array();
var error_lookaheads = new Array();
var error_count = 0;
var DEBUG = false;
var TESTS = false;
var FILE = false;
var TEST_COUNT = 0;
var TEST_ERRORS = 0;
var TEST_PASSES = 0;

var PASSED = true;

console.log("Welcome to the Scheme REPL");

process.stdin.resume();
process.stdin.setEncoding('utf8');

process.argv.forEach(function (val, index, array) {

    if( val === '-f' ){
        
        FILE = array[index + 1];
    }
    else if( val === '-t' ) {
        
        TESTS = true;
    }
});

if (TESTS) {
    
    process.stdout.write("\n==== Running Tests ====\n\n");
    
    var parseTest = require('./tests/parseTest.js');
        
    for ( i = 0; i < parseTest.tests.length; i++ ) {
        
        __NODEJS_parse( parseTest.tests[i], error_offsets, error_lookaheads );
        
        if ( JSON.stringify(parse.tokenized) != parseTest.expected[i] ) {
            
            process.stdout.write("Failed tests at: " + parseTest.tests[i] + "\n");
            process.stdout.write("Expected:  " + parseTest.expected[i] + "\n");
            process.stdout.write("Recieved:  " + JSON.stringify(parse.tokenized) + "\n\n");
            TEST_ERRORS++;
            PASSED = false;
        }
        else {
            TEST_PASSES++;
        }
        

        TEST_COUNT++;        
    }
        
    process.stdout.write(TEST_PASSES + " successfully tests\n");
    process.stdout.write(TEST_ERRORS + " failed tests\n");
    process.stdout.write(TEST_COUNT + " total tests\n\n");
}


//
// If we passed all of the test go to the REPL.
//
if (PASSED) {
    if( !FILE ) process.stdout.write("> ");
}
else
    process.exit(1);
    
    
    
if ( FILE ) {
    
    var fs = require('fs');
    var array = fs.readFileSync(FILE).toString().split("\n");
    
    
    
    var count = 0;
    for(i in array) {
        array[i] = array[i].trim();
        console.log( ++count + "\t" + array[i]);
    }
    
    
    for(i in array) {
        
        if( ( error_count = __NODEJS_parse( array[i], error_offsets, error_lookaheads ) ) > 0 ) {
        
            for( var i = 0; i < error_count; i++ )
                console.log( "Parse error near:_" + text.substr( error_offsets[i] ) + ", expecting \"" + error_lookaheads[i].join() + "\"" );
        }
        else {
        
            var eval = evaluation.eval(parse.tokenized);
            
            //
            // TODO: If we have a cons at this point then we need to turn it into "scheme" to be printed.
            //
        
            console.log(eval);
        }
    }
}


process.stdin.on('data', function (text) {


    text = text.trim();

    if( text != "" ) {

        if (text.toLowerCase() == 'print alist') {

            evaluation.printSymbols();
        }
        else if (text.toLowerCase() == 'print tokens') {

            parse.print(); 
        }
        else {

            if( ( error_count = __NODEJS_parse( text, error_offsets, error_lookaheads ) ) > 0 ) {

                for( var i = 0; i < error_count; i++ )
                    console.log( "Parse error near:_" + text.substr( error_offsets[i] ) + ", expecting \"" + error_lookaheads[i].join() + "\"" );
            }
            else {
    
                var eval = evaluation.eval(parse.tokenized);
                
                //
                // TODO: If we have a cons at this point then we need to turn it into "scheme" to be printed.
                //

                console.log(eval);
            }
        }
    }
    process.stdout.write("> ");
});
*]